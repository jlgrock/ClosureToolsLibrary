package com.github.jlgrock.closuretoolslibrary.compiler

import org.apache.log4j.Logger

import com.github.jlgrock.closuretoolslibrary.utils.io.DirectoryIO

/**
 * Represents a dependency that is used to build and walk a tree. This is a
 * direct port from the google python script.
 * 
 */
final class CalcDeps {

	/**
	 * Generated Message.
	 */
	static final GENERATED_MSG = '\n// This file was autogenerated by CalcDeps.java\n'
	
	/**
	 * Private Constructor for Utility Class.
	 */
	private CalcDeps() {
	}

	/**
	 * The Logger.
	 */
	static final Logger LOGGER = Logger.getLogger(CalcDeps)

	/**
	 * Build a list of dependencies from a list of files. Takes a list of files,
	 * extracts their provides and requires, and builds out a list of dependency
	 * objects.
	 * 
	 * @param googleBaseJS
	 *            the location of base.js in the google library
	 * @param files
	 *            a list of files to be parsed for goog.provides and
	 *            goog.requires.
	 * @return A list of dependency objects, one for each file in the files
	 *         argument.
	 * @throws IOException
	 *             if there is a problem parsing the files for dependency info
	 */
	private static Map<File, DependencyInfo> buildDependenciesFromFiles(
			final File googleBaseJS, final Collection<File> files)
			throws IOException {
		Map<File, DependencyInfo> result = [:]
		Set<File> searchedAlready = [:] as Set
		for (File file : files) {
			if (!searchedAlready.contains(file) && file != googleBaseJS) {
				DependencyInfo dep = AnnotationFileReader
						.parseForDependencyInfo(file)
				result.put(file, dep)
				searchedAlready.add(file)
			}
		}
		result
	}

	/**
	 * Calculates the dependencies for given inputs.
	 * 
	 * This method takes a list of paths (files, directories) and builds a
	 * searchable data structure based on the namespaces that each .js file
	 * provides. It then parses through each input, resolving dependencies
	 * against this data structure. The final output is a list of files,
	 * including the inputs, that represent all of the code that is needed to
	 * compile the given inputs.
	 * 
	 * @param baseJs
	 *            the base.js file that is in the closure library
	 * @param paths
	 *            the references (files, directories) that are used to build the
	 *            dependency hash.
	 * @param inputs
	 *            the inputs (files, directories, namespaces) that have
	 *            dependencies that need to be calculated.
	 * @return A list of all files, including inputs, that are needed to compile
	 *         the given inputs.
	 * @throws IOException
	 *             if there is a problem parsing the files
	 */
	private static List<DependencyInfo> calculateDependencies(
			final File baseJs, final Collection<File> inputs,
			final Collection<File> paths) throws IOException {
		Set<File> temp = [:] as Set
		temp.addAll(inputs)
		Map<File, DependencyInfo> inputHash = buildDependenciesFromFiles(
				baseJs, inputs)
		Map<File, DependencyInfo> searchHash = buildDependenciesFromFiles(
				baseJs, paths)
		LOGGER.info('Dependencies Calculated.')

		List<DependencyInfo> sortedDeps = slowSort(inputHash.values(),
				searchHash.values())
		LOGGER.info('Dependencies Sorted.')
		sortedDeps
	}

	/**
	 * Print out a deps.js file from a list of source paths.
	 * 
	 * @param googleBaseFile
	 *            the location of base.js in the google library
	 * @param sortedDeps
	 *            The sorted list of dependencies
	 * @param outputFile
	 *            The output file.
	 * @throws IOException
	 *             if there is a problem writing the file
	 * @return True on success, false if it was unable to find the base path to
	 *         generate deps relative to.
	 */
	private static boolean outputDeps(final File googleBaseFile,
			final Collection<DependencyInfo> sortedDeps, final File outputFile)
			throws IOException {
		DirectoryIO.genDir(outputFile.parentFile)
		FileWriter fw = new FileWriter(outputFile)
		BufferedWriter buff = new BufferedWriter(fw)

		buff.with {
			append(GENERATED_MSG)
			for (DependencyInfo fileDep : sortedDeps) {
				if (fileDep != null) {
					write(fileDep.toDepsString(googleBaseFile))
					write('\n')
					flush()
				}
			}
		}
		LOGGER.info('Deps file written.')
		true
	}

	/**
	 * Print out a requires.js file from a list of source paths.
	 * 
	 * @param googleBaseFile
	 *            the location of base.js in the google library
	 * @param sortedDeps
	 *            The sorted list of dependencies
	 * @param outputFile
	 *            The output file.
	 * @throws IOException
	 *             if there is a problem writing the file
	 * @return True on success, false if it was unable to find the base path to
	 *         generate deps relative to.
	 */
	private static boolean outputRequires(final File googleBaseFile,
			final Collection<DependencyInfo> sortedDeps, final File outputFile)
			throws IOException {
		DirectoryIO.genDir(outputFile.parentFile)
		FileWriter fw = new FileWriter(outputFile)
		BufferedWriter buff = new BufferedWriter(fw)

		buff.with {
			append(GENERATED_MSG)
			for (DependencyInfo fileDep : sortedDeps) {
				if (fileDep != null) {
					write(fileDep.toRequiresString(googleBaseFile))
					flush()
				}
			}
		}
		LOGGER.info('Requires file written.')
		true
	}

	/**
	 * Compare every element to one another. This is significantly slower than a
	 * merge sort, but guarantees that deps end up in the right order
	 * 
	 * @param inputs
	 *            the inputs to scan
	 * @param deps
	 *            the external dependencies
	 * @return the list of dependencyInfo objects
	 */
	private static List<DependencyInfo> slowSort(
			final Collection<DependencyInfo> inputs,
			final Collection<DependencyInfo> deps) {
		Map<String, DependencyInfo> searchSet = buildSearchList(deps)
		Set<File> seenList = [:] as Set
		List<DependencyInfo> resultList = []
		for (DependencyInfo input : inputs) {
			if (!seenList.contains(input.file)) {
				seenList.add(input.file)
				for (String require : input.requires) {
					orderDependenciesForNamespace(input.file, require,
							searchSet, seenList, resultList)
				}
				resultList.add(input)
			}
		}
		resultList
	}

	/**
	 * Will order the Dependencies for a single namespace.
	 * 
	 * @param inputFile
	 *            the file
	 * @param requireNamespace
	 *            whether or not to require the namespace
	 * @param searchSet
	 *            the set to search through
	 * @param seenList
	 *            the list of objects that have been seen already (which may be
	 *            added to)
	 * @param resultList
	 *            the resulting list which will be added to
	 */
	private static void orderDependenciesForNamespace(final File inputFile,
			final String requireNamespace,
			final Map<String, DependencyInfo> searchSet,
			final Set<File> seenList,
			final List<DependencyInfo> resultList) {
		if (!searchSet.containsKey(requireNamespace)) {
			LOGGER.error("Problem with require in file '${inputFile.absolutePath()}"
					+ "'. Found goog.require for '${requireNamespace}" + 
					+ "', but did not find a corresponding goog.provide.")
		}
		DependencyInfo dep = searchSet.get(requireNamespace)
		if (!seenList.contains(dep.file)) {
			seenList.add(dep.file)
			for (String subRequire : dep.requires) {
				orderDependenciesForNamespace(dep.file, subRequire,
						searchSet, seenList, resultList)
			}
			resultList.add(dep)
		}
	}

	/**
	 * Build the search list for seraching for dependencies.
	 * 
	 * @param deps
	 *            the external dependencies
	 * @return the list of external dependencies, hashed by the namespace
	 */
	private static Map<String, DependencyInfo> buildSearchList(
			final Collection<DependencyInfo> deps) {
		Map<String, DependencyInfo> returnVal = [:]
		for (DependencyInfo dep : deps) {
			for (String provide : dep.provides) {
				returnVal.put(provide, dep)
			}
		}
		returnVal
	}

	/**
	 * convert the sortedDependency list into a list of files.
	 * 
	 * @param sortedDeps
	 *            the sorted dependencies
	 * @return the sorted list of files
	 */
	private static List<File> pullFilesFromDeps(
			final List<DependencyInfo> sortedDeps) {
		List<File> returnVal = []
		for (DependencyInfo dep : sortedDeps) {
			returnVal.add(dep.file)
		}
		returnVal
	}

	/**
	 * This will sort the list of dependencies, write a dependency file, and
	 * return the list of dependencies.
	 * 
	 * @param googleBaseFile
	 *            the base.js file that is in the google closure library
	 * @param inputs
	 *            the set of input files to parse for provides and requires
	 * @param paths
	 *            to additional resources that will have provides and requires
	 * @param depsFile
	 *            the deps file
	 * @param requiresFile
	 *            the requires file
	 * @return the list of calculated dependencies, just in case it is needed
	 * @throws IOException
	 *             if there is a problem reading from any dependencies or
	 *             writing the depenency file
	 */
	static List<File> executeCalcDeps(final File googleBaseFile,
			final Collection<File> inputs, final Collection<File> paths,
			final File depsFile, final File requiresFile) throws IOException {
		LOGGER.debug('Finding Closure dependencies...')
		List<DependencyInfo> sortedDeps = calculateDependencies(googleBaseFile,
				inputs, paths)

		// create deps file
		LOGGER.debug('Outputting Closure dependency file...')
		outputDeps(googleBaseFile, sortedDeps, depsFile)

		// create deps file
		if (requiresFile != null) {
			LOGGER.debug('Outputting Closure dependency requires file...')
			outputRequires(googleBaseFile, sortedDeps, requiresFile)
		}

		LOGGER.debug('Closure dependencies created')
		pullFilesFromDeps(sortedDeps)
	}

}
